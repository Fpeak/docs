import Doc from '~/components/layout/docs'
import { GenericLink } from '~/components/text/link'
import { Image } from '~/components/media'
import Caption from '~/components/text/caption'

export const meta = {
  title: 'Deployments',
  description: 'Understanding and making deployments with ZEIT Now.',
  editUrl: 'pages/docs/v2/advanced/platform/deployments.mdx',
  lastEdited: '2019-10-18T21:50:53.000Z'
}

A deployment is the end result of building your project and making it available to visitors.

This section contains information about making, managing and understanding the behavior of deployments.

## Making Deployments

### Git integration

### Now CLI

### Now API

## Managing Deployments

### ZEIT Dashboard

### Now CLI

## Deployment Types

There are two types of deployment on the ZEIT Now platform, **staging** and **production**.

### Staging

**Staging deployments** are the default for all deployments. Each time you push to a branch or make a deployment using the `now` command, this is a **staging deployment**.

By making a **staging deployment**, the **staging domain** will be updated to reflect that of the latest deployment made.

The **staging domain** is provided either by the deployment output from Now CLI or on a pull request when using a git integration and contains the name of the user or team the project belongs to.

### Production

**Production deployments** are made in two different circumstances. Each time you merge to the default branch (commonly `master`) or make a deployment using the `now --prod` command, this is a **production deployment**.

By making a **production deployment**, the **production domain(s)** will be updated to reflect that of the latest deployment made.

The **production domain(s)** are defined from the **Domains** tab of a project on the ZEIT Dashboard.

## Immutability

For a ZEIT Now deployment to be created, our API requires the client to include a description of the project directory structure and content, expressed as a series of [checksums](https://en.wikipedia.org/wiki/Checksum).

If our system finds a sourcefile checksum to be missing in our database, it will request the client to upload it and retry.

Next, our system decides if a **new** deployment is necessary, based on the project config and sources. If they match an existing deployment, we return its [Deployment URL](/docs/v2/advanced/concepts/urls).

It is worth pointing out that there is no notion of **editing or modifying an existing deployment**. When you make a source or config change, a new deployment is always created.

### Motivation

Immutability enables many important properties for scalable deployments and large teams / repositories.

### Instant Git Reverts

With ZEIT Now + Github, if a PR is merged that yields an undesirable outcome, it should be quickly reverted. Similarly, one can revert a commit in any branch of a vanilla `git` repository.

Due to the [Now deduplication algorithm](#deduplication-algorithm), if a deployment existed in the past that matches the new source code state.

### Improved Collaboration

Immutability enables projects with many different developers to be effectively deployable without any sort of inhibition.

There is no situation where the changes pushed or deployed by a certain individual or team will step over or overwrite others' changes.

### Deduplication Algorithm

The [URL structure](/docs/v2/advanced/concepts/urls) of each deployment contains in the **subdomain**, the name of the application and a random UID.

We decide to generate a new UID (and therefore a new deployment), by combining the following information into an internal digest that we look up in our database:

- The entire deployment configuration from `now.json`
- The owner ID (either the user ID or team ID, if deploying within a team)
- The description of the filesystem. This includes symlinks, [modes](<https://en.wikipedia.org/wiki/Modes_(Unix)>), pathnames and the [checksum](https://en.wikipedia.org/wiki/Checksum) of each file's contents

We ensure the digest is computed [deterministically](https://en.wikipedia.org/wiki/Deterministic_algorithm) by sorting and ordering all the inputs involved in the algorithm.

Our lookup excludes deployments that are in an `ERROR` [state](/docs/v2/advanced/concepts/lifecycle). If a previous deployment matches the digest but failed to build correctly.

### Skipping deduplication

There are two ways to force a **new** deployment to be created when our system would otherwise deduplicate.

- **Make any change** to any of the parameters considered by the algorithm above. For example, even changing one character in a comment of a source file yields a new deployment.
- **Force a new deployment** by instructing your client to do so.
  - For [Now CLI](/download) you can run `now --force`
  - If using our API, include the [`forceNew` query parameter](/docs/api/v2#endpoints/deployments/create-a-new-deployment)

## Special Paths

All deployment URLs have two special pathnames:

- `/_src`
- `/_logs`

### Source view

By appending `/_src` to a [deployment URL](/docs/v2/advanced/concepts/urls) or [custom domain](/docs/v2/custom-domains), the deployment inspector will be open and you'll be able to browse your deployment sources and [build](/docs/v2/advanced/builders) outputs.

### Logs view

By appending `/_logs` to a [deployment URL](/docs/v2/advanced/concepts/urls) or [custom domain](/docs/v2/custom-domains), you will be able to see a realtime stream of logs from your deployment build processes and serverless invocations.

### Security considerations

These pathnames redirect to `https://zeit.co` and _require logging in_ to access any sensitive information. A 3rd-party can _never_ access your source or logs by crafting a deployment URL with one of these paths.

export default ({ children }) => <Doc meta={meta}>{children}</Doc>

export const config = {
  amp: 'hybrid'
}
